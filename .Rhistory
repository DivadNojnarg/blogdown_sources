n_init <- seq(1,length(state), by = 1)
names(state) <- paste("n =", n_init)
state
state <- t(replicate(5, sample(1:100,size=3), simplify="array"))
n_init <- seq(1,length(state), by = 1)
names(state) <- paste("n =", n_init)
state
library(Rcpp)
library(odeintr)
library(rgl)
pars = c(sigma = 10, R = 28, b = 8/3)
Lorenz.sys = ' dxdt[0] = sigma * (x[1] - x[0]);
dxdt[1] = R * x[0] - x[1] - x[0] * x[2];
dxdt[2] = -b * x[2] + x[0] * x[1];
' # Lorenz.sys
cat(JacobianCpp(Lorenz.sys))
compile_implicit("lorenz", Lorenz.sys, pars, TRUE)
Lorenz_sim<- function(x0){
state <- c(x0[1],
x0[2],
x0[3])
out = as.data.frame(lorenz(state, 100, 0.003))
}
state <- t(replicate(5, sample(1:100,size=3), simplify="array"))
n_init <- seq(1,length(state), by = 1)
names(state) <- paste("n =", n_init)
list_out <- apply(state, 2, Lorenz_sim)
list_out <- apply(state, 1, Lorenz_sim)
out_1 <-list_out[[1]]
plot(out_1, upper.panel = NULL)
plot3d(out_1$X1, out_1$X2, out_1$X3)
ldf <- do.call(rbind, lapply(names(list_out),
function(x) data.frame(list_out[[x]], x, stringsAsFactors = FALSE)))
ldf <- do.call(rbind, apply(names(list_out),1,
function(x) data.frame(list_out[[x]], x, stringsAsFactors = FALSE)))
list_out <- data.frame(apply(state, 1, Lorenz_sim),names(state))
list_out
list_out <- cbind(apply(state, 1, Lorenz_sim),names(state))
names(state)
t(names(state))
list_out
list_out <- apply(state, 1, Lorenz_sim),names(state)
list_out <- apply(state, 1, Lorenz_sim),names(state))
list_out <- apply(state, 1, Lorenz_sim)
ldf <- do.call(rbind, lapply(names(state),
function(x) data.frame(list_out[[x]], x, stringsAsFactors = FALSE)))
library(deSolve)
library(parallel)
# initiate parallel computing
no_cores <- detectCores() -1
cl <- makeCluster(no_cores)
# Model equations
parameters <- c(r = 0.3, K = 10000, fom = 0)
state <- c(N = 150)
Logistic <- function(t, state, parameters) {
with(as.list(c(state, parameters)), {
# rate of change
dN <- (1 - fom) * (r * N * (1 - N / K))
# return the result
list(dN)
}) # end with(as.list ...
}
times <- seq(0, 300, by = 0.2)
fracts <- seq(0, 0.9, by = 0.1)
names(fracts) <- paste("frac =", fracts)
# export all previous variables to each R process belonging to the cluster
clusterExport(cl=cl, varlist=c("parameters", "state", "times", "fracts","ode","Logistic"))
list_results <- parLapply(cl, fracts, function(x) {
parameters["fom"] <- x
ode(y = state, times = times, func = Logistic, parms = parameters)
})
list_results
ldf <- do.call(rbind, parLapply(cl, names(list_results),
function(x) data.frame(list_results[[x]], x, stringsAsFactors = FALSE)))
clusterExport(cl=cl, varlist=c("list_results"))
ldf <- do.call(rbind, parLapply(cl, names(list_results),
function(x) data.frame(list_results[[x]], x, stringsAsFactors = FALSE)))
ldf
library(Rcpp)
library(odeintr)
library(rgl)
pars = c(sigma = 10, R = 28, b = 8/3)
Lorenz.sys = ' dxdt[0] = sigma * (x[1] - x[0]);
dxdt[1] = R * x[0] - x[1] - x[0] * x[2];
dxdt[2] = -b * x[2] + x[0] * x[1];
' # Lorenz.sys
cat(JacobianCpp(Lorenz.sys))
compile_implicit("lorenz", Lorenz.sys, pars, TRUE)
Lorenz_sim<- function(x0){
state <- c(x0[1],
x0[2],
x0[3])
out = as.data.frame(lorenz(state, 100, 0.003))
}
state <- t(replicate(5, sample(1:100,size=3), simplify="array")) # initial conditions are now in line
n_init <- seq(1,length(state), by = 1)
names(state) <- paste("n =", n_init) # give an index to initial condition for each line
list_out <- apply(state, 1, Lorenz_sim)
head(list_out[[1]])
names(list_out)
library(deSolve)
library(parallel)
# initiate parallel computing
no_cores <- detectCores() -1
cl <- makeCluster(no_cores)
# Model equations
parameters <- c(r = 0.3, K = 10000, fom = 0)
state <- c(N = 150)
Logistic <- function(t, state, parameters) {
with(as.list(c(state, parameters)), {
# rate of change
dN <- (1 - fom) * (r * N * (1 - N / K))
# return the result
list(dN)
}) # end with(as.list ...
}
times <- seq(0, 300, by = 0.2)
fracts <- seq(0, 0.9, by = 0.1)
names(fracts) <- paste("frac =", fracts)
# export all previous variables to each R process belonging to the cluster
clusterExport(cl=cl, varlist=c("parameters", "state", "times", "fracts","ode","Logistic"))
list_results <- parLapply(cl, fracts, function(x) {
parameters["fom"] <- x
ode(y = state, times = times, func = Logistic, parms = parameters)
})
names(list_results)
state <- t(replicate(5, sample(1:100,size=3), simplify="array")) # initial conditions are now in line
n_init <- seq(1,length(state), by = 1)
names(state) <- paste("n =", n_init)
head(state)
state <- t(replicate(5, sample(1:100,size=3), simplify="array")) # initial conditions are now in line
n_init <- seq(1,length(state), by = 1)
names(n_init) <- paste("n =", n_init)
head(n_init)
n_init <- t(seq(1,length(state), by = 1))
names(n_init) <- paste("n =", n_init) # give an index to initial condition for each line
head(n_init)
state <- t(replicate(5, sample(1:100,size=3), simplify="array")) # initial conditions are now in line
state
is.matrix(state)
n_init <- seq(1,length(state), by = 1)
n_init
dim(state)
dim(state)[1]
state <- t(replicate(5, sample(1:100,size=3), simplify="array")) # initial conditions are now in line
n_init <- seq(1,dim(state)[1], by = 1)
names(state) <- paste("n =", n_init)
state
names(n_init) <- paste("n =", n_init) # give an index to initial condition for each line
n_init
library(Rcpp)
library(odeintr)
library(rgl)
pars = c(sigma = 10, R = 28, b = 8/3)
Lorenz.sys = ' dxdt[0] = sigma * (x[1] - x[0]);
dxdt[1] = R * x[0] - x[1] - x[0] * x[2];
dxdt[2] = -b * x[2] + x[0] * x[1];
' # Lorenz.sys
cat(JacobianCpp(Lorenz.sys))
compile_implicit("lorenz", Lorenz.sys, pars, TRUE)
Lorenz_sim<- function(x0){
state <- c(x0[1],
x0[2],
x0[3])
out = as.data.frame(lorenz(state, 100, 0.003))
}
state <- t(replicate(5, sample(1:100,size=3), simplify="array")) # initial conditions are now in line
n_init <- seq(1,dim(state)[1], by = 1)
names(n_init) <- paste("n =", n_init) # give an index to initial condition for each line
list_out <- apply(state, 1, Lorenz_sim)
ldf <- do.call(rbind, lapply(names(list_out),
function(x) data.frame(list_out[[x]], x, stringsAsFactors = FALSE)))
library(deSolve)
library(parallel)
# initiate parallel computing
no_cores <- detectCores() -1
cl <- makeCluster(no_cores)
# Model equations
parameters <- c(r = 0.3, K = 10000, fom = 0)
state <- c(N = 150)
Logistic <- function(t, state, parameters) {
with(as.list(c(state, parameters)), {
# rate of change
dN <- (1 - fom) * (r * N * (1 - N / K))
# return the result
list(dN)
}) # end with(as.list ...
}
times <- seq(0, 300, by = 0.2)
fracts <- seq(0, 0.9, by = 0.1)
names(fracts) <- paste("frac =", fracts)
# export all previous variables to each R process belonging to the cluster
clusterExport(cl=cl, varlist=c("parameters", "state", "times", "fracts","ode","Logistic"))
list_results <- parLapply(cl, fracts, function(x) {
parameters["fom"] <- x
ode(y = state, times = times, func = Logistic, parms = parameters)
})
names(list_results)
library(Rcpp)
library(odeintr)
library(rgl)
pars = c(sigma = 10, R = 28, b = 8/3)
Lorenz.sys = ' dxdt[0] = sigma * (x[1] - x[0]);
dxdt[1] = R * x[0] - x[1] - x[0] * x[2];
dxdt[2] = -b * x[2] + x[0] * x[1];
' # Lorenz.sys
cat(JacobianCpp(Lorenz.sys))
compile_implicit("lorenz", Lorenz.sys, pars, TRUE)
Lorenz_sim<- function(x0){
state <- c(x0[1],
x0[2],
x0[3])
out = as.data.frame(lorenz(state, 100, 0.003))
}
state <- t(replicate(5, sample(1:100,size=3), simplify="array")) # initial conditions are now in line
n_init <- seq(1,dim(state)[1], by = 1)
names(state) <- paste("n =", n_init) # give an index to initial condition for each line
head(state)
names(state) <- paste("n =", n_init)
names(state)
state <- t(data.frame(replicate(5, sample(1:100,size=3), simplify="array")) # initial conditions are now in line
)
head(state)
names(state) <- paste("n =", n_init)
state
state <- t(replicate(5, sample(1:100,size=3), simplify="array")) # initial conditions are now in line
n_init <- seq(1,dim(state)[1], by = 1)
rownames(state) <- paste("n =", n_init)
state
list_out <- apply(state, 1, Lorenz_sim)
names(list_out)
ldf <- do.call(rbind, lapply(names(list_out),
function(x) data.frame(list_out[[x]], x, stringsAsFactors = FALSE)))
head(ldf)
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
df <- data.frame(name = sample(letters, 100, TRUE), date = sample(1:500, 100, TRUE))
df
library(Rcpp)
library(odeintr)
library(rgl)
pars = c(sigma = 10, R = 28, b = 8/3)
Lorenz.sys = ' dxdt[0] = sigma * (x[1] - x[0]);
dxdt[1] = R * x[0] - x[1] - x[0] * x[2];
dxdt[2] = -b * x[2] + x[0] * x[1];
' # Lorenz.sys
cat(JacobianCpp(Lorenz.sys))
compile_implicit("lorenz", Lorenz.sys, pars, TRUE)
Lorenz_sim<- function(x0){
state <- c(x0[1],
x0[2],
x0[3])
out = as.data.frame(lorenz(state, 100, 0.003))
}
state <- t(replicate(5, sample(1:100,size=3), simplify="array")) # initial conditions are now in line
n_init <- seq(1,dim(state)[1], by = 1)
rownames(state) <- paste("n =", n_init) # give an index to initial condition for each line
list_out <- apply(state, 1, Lorenz_sim)
data_out <- do.call(rbind, lapply(names(list_out),
function(x) data.frame(list_out[[x]], x, stringsAsFactors = FALSE)))
names[data_out]
head(data_out)
data_out$x
data_out[data_out$x == 1]
data_out[data_out$x == "n=1"]
head(data_out)
data_out[data_out$x == "n=1",]
data_out[data_out$x == 1,]
data_out$x
data_out$x$
ldld
data_out$x$[n==1]
data_out$x[n==1]
data_out$x["n=1"]
library(Rcpp)
library(odeintr)
library(rgl)
pars = c(sigma = 10, R = 28, b = 8/3)
Lorenz.sys = ' dxdt[0] = sigma * (x[1] - x[0]);
dxdt[1] = R * x[0] - x[1] - x[0] * x[2];
dxdt[2] = -b * x[2] + x[0] * x[1];
' # Lorenz.sys
cat(JacobianCpp(Lorenz.sys))
compile_implicit("lorenz", Lorenz.sys, pars, TRUE)
Lorenz_sim<- function(x0){
state <- c(x0[1],
x0[2],
x0[3])
out = as.data.frame(lorenz(state, 100, 0.003))
}
state <- t(replicate(5, sample(1:100,size=3), simplify="array")) # initial conditions are now in line
n_init <- seq(1,dim(state)[1], by = 1)
rownames(state) <- paste(n_init) # give an index to initial condition for each line
list_out <- apply(state, 1, Lorenz_sim)
data_out <- do.call(rbind, lapply(names(list_out),
function(x) data.frame(list_out[[x]], x, stringsAsFactors = FALSE)))
head(data_out)
data_out[data_out$x == 1,]
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
data_out[data_out$x == 1,-5]
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
library(Rcpp)
library(odeintr)
library(rgl)
pars = c(sigma = 10, R = 28, b = 8/3)
Lorenz.sys = ' dxdt[0] = sigma * (x[1] - x[0]);
dxdt[1] = R * x[0] - x[1] - x[0] * x[2];
dxdt[2] = -b * x[2] + x[0] * x[1];
' # Lorenz.sys
cat(JacobianCpp(Lorenz.sys))
compile_implicit("lorenz", Lorenz.sys, pars, TRUE)
Lorenz_sim<- function(x0){
state <- c(x0[1],
x0[2],
x0[3])
out = as.data.frame(lorenz(state, 100, 0.003))
}
state <- t(replicate(5, sample(1:100,size=3), simplify="array")) # initial conditions are now in line
n_init <- seq(1,dim(state)[1], by = 1)
rownames(state) <- paste(n_init) # give an index to initial condition for each line
list_out <- apply(state, 1, Lorenz_sim)
data_out <- do.call(rbind, lapply(names(list_out),
function(x) data.frame(list_out[[x]], x, stringsAsFactors = FALSE)))
nrow(state)
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
# suppression de tous les objets R contenus en memoire
#-----------------------------------------------------
library(leaflet)
library(shiny)
library(shinydashboard)
library(plotly)# pour rendre les graph interactifs
library(dplyr)
# --- importation et préparation des donnees de débit (DebitHoraire) de Romagnieu
#---------------------------------------------------------------------------------------------
DebitHoraire1 <- read.csv2("Debit Guiers à Belmont horaire GGplot2.csv", sep = ";"
, header = TRUE, stringsAsFactors = FALSE,na.strings = "#N/A")
DebitHoraire1$DateHeure=as.POSIXct(DebitHoraire1$DateHeure,format="%d/%m/%y %H")
DebitHoraire1$Debit=as.numeric(DebitHoraire1$Debit)
# --- importation et préparation des donnees de débit (DebitHoraire) de Lavoute
#---------------------------------------------------------------------------------------------
DebitHoraire2 <- read.csv2("Débit Loire à Chadrac horaire vers J.csv", sep = ";"
, header = TRUE, stringsAsFactors = FALSE,na.strings = "#N/A")
DebitHoraire2$DateHeure=as.POSIXct(DebitHoraire2$DateHeure,format="%d/%m/%y %H")
DebitHoraire2$Debit=as.numeric(DebitHoraire2$Debit)
#Stockage des données dans une liste.
graphStack=list(DebitHoraire1,DebitHoraire2)
# -----------------------------------------------------------------------------------------------------------------------------------------
# Parametrage onglet observation
# ----------------------------------------------------------------------------------------------------------------------------------
# COULEUR et palette
# gestion des donnees
PALETTES = list()
# Sites suivis
PALETTES$Suivi$distr <- c("Terminé", "En cours","A venir","Visite")
PALETTES$Suivi$colours <- c("#FF7F00", #orange suivi termine
"#009900", #vert suivi en cours
"#FFFF00", #jaune suivi planifié
"#436EEE" #bleu visite de site
)
myData=read.table("Sites.txt", header=TRUE,sep="\t")
data.frame(myData)
shinyUI=dashboardPage(
# Header
dashboardHeader(title = "Suivis Pit-Tag - Charriage",titleWidth = 450,
dropdownMenuOutput("messageMenu1"),
dropdownMenuOutput("messageMenu2"),
disable = FALSE),
# Barre de menu
dashboardSidebar(
sidebarMenu(id="menu",menuItem("Les sites de mesures", tabName = "sites")
)
), #end dashboard sidebar
# Corps
dashboardBody(
tabItem(tabName = "sites",
navbarPage(title = '',id = "visuobs", #fluid = TRUE,
tabPanel("Synthèse",value = "pr",
column(width=7,#premiere colonne
box(width = 12, solidHeader = FALSE, status = "primary",
leafletOutput("map",height = 700)
)
),#end premiere colonne
column(width=5,#deuxieme colonne
box(width =12, solidHeader = FALSE, status = "primary",
tags$head(tags$style(HTML(mycss))),
div(id = "plot-container",
tags$img(src = "spinner.gif",
id = "loading-spinner"),
plotlyOutput('graph',height = 400),
p(),
tableOutput("myTable")
)#end div
)
)#end deuxieme colonne
) # end tab panel RR
) # end navbar page
) # end tab item
) # end dashboardbody
)
server <- function(input, output, session) {
data <- reactiveValues(clickedMarker=NULL)
#Carto synthese mesures Pit
output$map <- renderLeaflet({
map <- leaflet(data=myData) %>%  setView(3.3, 44.9, zoom = 7) %>%
addLegend(position = "bottomright",
title="Suivis Pit",
colors = PALETTES$Suivi$colours,
labels = c(paste(PALETTES$Suivi$distr,sep="")),
opacity = 0.8) %>%
#addTiles('http://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}')%>%
addProviderTiles("Thunderforest.Landscape",
options = providerTileOptions(noWrap = TRUE)) %>%
addMarkers(data=myData,popup=myData$LIB_LIEU,icon =,clusterOptions = markerClusterOptions(),
layerId = myData$id)
map
}) # end renderLeaflet
# observe si il y a un click sur un shape sur la carto
observeEvent(input$map_marker_click,{
print("observed map_marker_click")
event <- input$map_marker_click
# if (is.null(observeEvent)) return() # pour gérer les click en dehors des points qui génère un NULL
print(event)
output$myTable <- renderTable({
return(
subset(myData,id == event$id)
)
})
})
# observe si il y a un click sur un shape sur la carto
observeEvent(input$map_marker_click,{
print("observed map_marker_click")
event <- input$map_marker_click
#if (is.null(observeEvent)) return() # pour gérer les click en dehors des points qui génère un NULL
print(event)
output$graph=renderPlotly({
dta_tmp<-graphStack[[event$id]]
plot_ly(data=dta_tmp,x=~DateHeure,y=~Debit) %>%
layout(xaxis=list(title=" "),yaxis=list(title="Débit Horaire en m3/s"))
})
})
} #end
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
library(reshape2)
library(plotly)
#
pp <- function (n,r=4) {
x <- seq(-r*pi, r*pi, len=n)
df <- expand.grid(x=x, y=x)
df$r <- sqrt(df$x^2 + df$y^2)
df$z <- cos(df$r^2)*exp(-df$r/6)
df
}
data_xyz <- pp(100)
data_z <- acast(data_xyz, x~y, value.var = "z")
plot_ly(z = data_z,  type = "surface")
data <- read.csv('https://raw.githubusercontent.com/plotly/datasets/master/_3d-line-plot.csv')
head(data)
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
i=2:10
i
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
runApp('~/Dropbox/Learn_Shiny_R/App-1-Rcpp')
