install.packages("shinycssloader")
install.packages("shinyDND")
install.packages("ccSolve")
devtools::install_github('andrewsali/shinycssloaders')
shiny::runApp('Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra')
install.packages("Flexdashboard")
install.packages("Flexdashboard")
install.packages("Flexdashboard")
install.packages("flexdashboard")
install.packages("flexdashboard")
install.packages("flexdashboard")
install.packages("flexdashboard")
install.packages("flexdashboard")
install.packages("flexdashboard")
runApp('Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra')
runApp('Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra')
runApp('Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra')
runApp('Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra')
shiny::runApp('Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra')
runApp('Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra')
runApp('Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra')
shiny::runApp('Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra')
runApp('Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra')
runApp('Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra')
runApp('Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra')
setwd("~/Documents/divadnojnarg_sources")
setwd("~/Documents/blogdown_sources")
blogdown::build_site()
blogdown::build_site()
shiny::runApp('~/Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra')
a <- expand.grid(1:20, 1:20)
b <- matrix(a[,1] + a[,2], 20)
a
b
filled.contour(x = 1:20, y = 1:20, z = b,
plot.axes = { axis(1); axis(2); points(10, 10) })
x <- seq(pi/4, 5 * pi, length.out = 100)
y <- seq(pi/4, 5 * pi, length.out = 100)
r <- as.vector(sqrt(outer(x^2, y^2, "+")))
grid <- expand.grid(x=x, y=y)
grid$z <- cos(r^2) * exp(-r/(pi^3))
levelplot(z~x*y, grid, cuts = 50, scales=list(log="e"), xlab="",
ylab="", main="Weird Function", sub="with log scales",
colorkey = FALSE, region = TRUE)
install.packages("lattice")
x <- seq(pi/4, 5 * pi, length.out = 100)
y <- seq(pi/4, 5 * pi, length.out = 100)
r <- as.vector(sqrt(outer(x^2, y^2, "+")))
grid <- expand.grid(x=x, y=y)
grid$z <- cos(r^2) * exp(-r/(pi^3))
levelplot(z~x*y, grid, cuts = 50, scales=list(log="e"), xlab="",
ylab="", main="Weird Function", sub="with log scales",
colorkey = FALSE, region = TRUE)
library(lattice)
x <- seq(pi/4, 5 * pi, length.out = 100)
y <- seq(pi/4, 5 * pi, length.out = 100)
r <- as.vector(sqrt(outer(x^2, y^2, "+")))
grid <- expand.grid(x=x, y=y)
grid$z <- cos(r^2) * exp(-r/(pi^3))
levelplot(z~x*y, grid, cuts = 50, scales=list(log="e"), xlab="",
ylab="", main="Weird Function", sub="with log scales",
colorkey = FALSE, region = TRUE)
x = seq(-10, 10, length= 30)
y = x
f = function(x,y) { r = sqrt(xˆ2+yˆ2); 10 * sin(r)/r }
z = outer(x, y, f) #
x = seq(-10, 10, length= 30)
y = x
f = function(x,y) { r = sqrt(x^2+y^2); 10 * sin(r)/r }
z = outer(x, y, f) #
z
contour(x,y,z)
p <- plot_ly(x = x, y = y, z = z, type = "contour") %>% layout(autosize = F, width = 600, height = 500)
p <- plot_ly(x = x, y = y, z = z, type = "contour")
library(plotly)
p <- plot_ly(x = x, y = y, z = z, type = "contour")
p
shiny::runApp('~/Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra')
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
grid_lotka <- function(parameters){
x1grid <-  seq(0, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  seq(0, parameters["r1"]/parameters["c1"]*10, 0.3)
data.grid <-  expand.grid(x1_g = x1grid, x2_g = y2grid)
}
grid_lotka(parameters )
grid_lotka(parameters)
parameters["d2"]
parameters["d2"]/parameters["c2"]
parameters
parameters$d2
parameters[4]
grid_lotka <- function(parameters){
x1grid <-  seq(0, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  seq(0, parameters["r1"]/parameters["c1"]*10, 0.3)
data.grid <-  expand.grid(x1_g = x1grid, x2_g = x2grid)
}
grid_lotka(parameters)
grid_lotka
grid_lotka <- function(parameters){
x1grid <-  seq(0, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  seq(0, parameters["r1"]/parameters["c1"]*10, 0.3)
return(data.grid <-  expand.grid(x1_g = x1grid, x2_g = x2grid))
}
grid_lotka(parameters)
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
grid_lotka <- function(parameters){
x1grid <-  seq(0, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  seq(0, parameters["r1"]/parameters["c1"]*10, 0.3)
data.grid <-  expand.grid(x1_g = x1grid, x2_g = x2grid)
}
test<-grid_lotka(parameters)
test
ip_lotka <- function(parameters, x1_g, x2_g){
ip <- parameters["d2"]*log(x1_g) + parameters["r1"]*log(x2_g) - parameters["c1"]*x2_g - parameters["c2"]*x1_g
z <- outer(x1_g, x2_g, ip)
}
ip_lotka(parameters, x1_g, x2_g = )
ip_lotka(parameters, x1_g, x2_g)
ip_lotka(parameters, test$x1_g, test$x2_g)
x1_g <- grid_lotka(parameters)$x1_g
x1_g
ip <- parameters["d2"]*log(x1_g) + parameters["r1"]*log(x2_g) - parameters["c1"]*x2_g - parameters["c2"]*x1_g
x2_g <- grid_lotka(parameters)$x2_g
ip <- parameters["d2"]*log(x1_g) + parameters["r1"]*log(x2_g) - parameters["c1"]*x2_g - parameters["c2"]*x1_g
z <- outer(x1_g, x2_g, ip)
ip
persp(x1_g,x2_g,ip)
x1grid <-  seq(0, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  seq(0, parameters["r1"]/parameters["c1"]*10, 0.3)
ip <- parameters["d2"]*log(x1grid) + parameters["r1"]*log(x2grid) - parameters["c1"]*x2grid - parameters["c2"]*x1grid
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(0, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  seq(0, parameters["r1"]/parameters["c1"]*10, 0.3)
ip_lotka <- function(parameters, x1grid, x2grid){
ip <- parameters["d2"]*log(x1_g) + parameters["r1"]*log(x2_g) - parameters["c1"]*x2_g - parameters["c2"]*x1_g
}
z <- outer(x1_g, x2_g, ip_lotka)
z <- outer(x1grid, x2grid, ip_lotka)
ip_lotka <- function(parameters, x1grid, x2grid){
ip <- parameters["d2"]*log(x1grid) + parameters["r1"]*log(x2grid) - parameters["c1"]*x2grid - parameters["c2"]*x1grid
}
z <- outer(x1grid, x2grid, ip_lotka)
x1grid <-  seq(1, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  seq(1, parameters["r1"]/parameters["c1"]*10, 0.3)
ip_lotka <- function(parameters, x1grid, x2grid){
ip <- parameters["d2"]*log(x1grid) + parameters["r1"]*log(x2grid) - parameters["c1"]*x2grid - parameters["c2"]*x1grid
}
z <- outer(x1grid, x2grid, ip_lotka)
z <- outer(x1grid, x2grid, ip_lotka(parameters,x1grid,x2grid))
z <- outer(x1grid, x2grid, ip_lotka)
z =outer(x1grid, x2grid, ip_lotka)
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(0, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  x1grid
ip_lotka <- function(parameters, x1grid, x2grid){
ip <- parameters["d2"]*log(x1grid) + parameters["r1"]*log(x2grid) - parameters["c1"]*x2grid - parameters["c2"]*x1grid
}
z <- outer(x1grid, x2grid, ip_lotka)
data.grid <-  expand.grid(x1_g = x1grid, x2_g = x2grid)
234*234
data.grid
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(0, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  seq(0, parameters["r1"]/parameters["c1"]*10, 0.3)
data.grid <-  expand.grid(x1_g = x1grid, x2_g = x2grid)
ip_lotka <- function(parameters, x1grid, x2grid){
ip <- parameters["d2"]*log(x1grid) + parameters["r1"]*log(x2grid) - parameters["c1"]*x2grid - parameters["c2"]*x1grid
z <- outer(x1grid, x2grid, ip)
}
ip_lotka(parameters)
ip_lotka <- function(parameters, x1grid, x2grid){
parameters["d2"]*log(x1grid) + parameters["r1"]*log(x2grid) - parameters["c1"]*x2grid - parameters["c2"]*x1grid
}
z <- outer(x1grid, x2grid, ip_lotka)
x = seq(-10, 10, length= 30)
y = x
f = function(x,y) { r = sqrt(x^2+y^2) }
z = outer(x, y, f) # Forms matrixz using function f
par(mfrow = c(1,2))
persp(x,y,z)
ip_lotka <- function(parameters, x1grid, x2grid){
ip = parameters["d2"]*log(x1grid) + parameters["r1"]*log(x2grid) - parameters["c1"]*x2grid - parameters["c2"]*x1grid
}
z <- outer(x1grid, x2grid, ip_lotka)
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(0, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  seq(0, parameters["r1"]/parameters["c1"]*10, 0.3)
data.grid <-  expand.grid(x1_g = x1grid, x2_g = x2grid)
ip = parameters["d2"]*log(data.grid$x1_g) + parameters["r1"]*log(data.grid$x2_g)
- parameters["c1"]*data.grid$x2_g - parameters["c2"]*data.grid$x1_g
persp(data.grid$x1_g, data.grid$x2_g, ip)
persp(x1grid, x2grid, ip)
x1grid <-  seq(0, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  seq(0, parameters["r1"]/parameters["c1"]*10, 0.3)
data.grid <-  expand.grid(x1_g = x1grid, x2_g = x2grid)
ip <- function(parameters, x1grid, x2grid){ z = parameters["d2"]*log(data.grid$x1_g) + parameters["r1"]*log(data.grid$x2_g)
- parameters["c1"]*data.grid$x2_g - parameters["c2"]*data.grid$x1_g
}
ip <- function(parameters, data.grid$x1_g, data.grid$x2_g){ z = parameters["d2"]*log(data.grid$x1_g) + parameters["r1"]*log(data.grid$x2_g)
- parameters["c1"]*data.grid$x2_g - parameters["c2"]*data.grid$x1_g
}
ip <- function(parameters, data.grid$x1_g, data.grid$x2_g){
z = parameters["d2"]*log(data.grid$x1_g) + parameters["r1"]*log(data.grid$x2_g)
- parameters["c1"]*data.grid$x2_g - parameters["c2"]*data.grid$x1_g
}
ip <- function(parameters, data.grid$x1_g, data.grid$x2_g){
z <- parameters["d2"]*log(data.grid$x1_g) + parameters["r1"]*log(data.grid$x2_g)
- parameters["c1"]*data.grid$x2_g - parameters["c2"]*data.grid$x1_g
}
x1grid <-  seq(0, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  x1grid
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(0, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  x1grid
data.grid <-  expand.grid(x1_g = x1grid, x2_g = x2grid)
ip <- function(parameters, data.grid$x1_g, data.grid$x2_g){
z <- parameters["d2"]*log(data.grid$x1_g) + parameters["r1"]*log(data.grid$x2_g)
- parameters["c1"]*data.grid$x2_g - parameters["c2"]*data.grid$x1_g
}
ip <- function(parameters, data.grid$x1_g, data.grid$x2_g){
z <- parameters["d2"]*log(data.grid$x1_g) + parameters["r1"]*log(data.grid$x2_g) - parameters["c1"]*data.grid$x2_g - parameters["c2"]*data.grid$x1_g
}
ip <- function(parameters, x1grid, x2grid){
z <- parameters["d2"]*log(x1grid) + parameters["r1"]*log(x2grid) - parameters["c1"]*x2grid - parameters["c2"]*x1grid
}
ip
ip(parameters,x1grid, x2grid)
test<-ip(parameters,x1grid, x2grid)
test
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(1, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  x1grid
data.grid <-  expand.grid(x1_g = x1grid, x2_g = x2grid)
ip <- function(parameters, x1grid, x2grid){
z <- parameters["d2"]*log(x1grid) + parameters["r1"]*log(x2grid) - parameters["c1"]*x2grid - parameters["c2"]*x1grid
}
ip_lotka <- ip(parameters,x1grid,x2grid)
contour(x1grid,x2grid,ip_lotka)
x = seq(-10, 10, length= 30)
y = x
f = function(x,y) { r = sqrt(x^2+y^2) }
z = outer(x, y, f)
z
x
ip_lotka <- outer(x1grid,x2grid,ip)
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(1, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  x1grid
ip <- function(parameters, x1grid, x2grid){
z = parameters["d2"]*log(x1grid) + parameters["r1"]*log(x2grid) - parameters["c1"]*x2grid - parameters["c2"]*x1grid
}
ip_lotka <- outer(x1grid,x2grid,ip)
ip_lotka <- outer(x = x1grid, y = x2grid,ip)
x = seq(-10, 10, length= 30)
class(x)
class(x1grid)
x1grid %o% x2grid
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(1, parameters["d2"]/parameters["c2"]*10, length = 30)
x2grid <-  x1grid
ip <- function(parameters, x1grid, x2grid){
z = parameters["d2"]*log(x1grid) + parameters["r1"]*log(x2grid) - parameters["c1"]*x2grid - parameters["c2"]*x1grid
}
ip_lotka <- outer(x = x1grid, y = x2grid,ip)
ip_lotka <- outer(X = x1grid, Y = x2grid,ip)
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(0.1, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  x1grid
ip <- function(parameters, x1grid, x2grid){
f = parameters["d2"]*log(x1grid) + parameters["r1"]*log(x2grid) - parameters["c1"]*x2grid - parameters["c2"]*x1grid
}
ip_lotka <- outer(x1grid, x2grid, ip)
ip_lotka = outer(x1grid, x2grid, ip)
x = seq(-10, 10, length= 30)
y = x
f = function(x,y) { r = sqrt(log(x^2)+log(y^2) }
z = outer(x, y, f) # Forms matrixz using function f
par(mfrow = c(1,2))
persp(x,y,z)
x = seq(0, 10, length= 30)
y = x
f = function(x,y) { r = sqrt(log(x^2)+log(y^2) }
z = outer(x, y, f) # Forms matrixz using function f
par(mfrow = c(1,2))
persp(x,y,z)
x = seq(1, 10, length= 30)
y = x
f = function(x,y) { r = sqrt(log(x^2)+log(y^2) }
z = outer(x, y, f) # Forms matrixz using function f
par(mfrow = c(1,2))
persp(x,y,z)
log(1)
x = seq(-10, 10, length= 30)
y = x
f = function(x,y) { r = sqrt(log(x^2)+log(y^2)) }
z = outer(x, y, f) # Forms matrixz using function f
par(mfrow = c(1,2))
persp(x,y,z)
rgl(x,y,z)
library(rgl)
rgl(x,y,z)
persp3d(x,y,z)
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(-2, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  x1grid
ip <- function(parameters, x1grid, x2grid){
f = parameters["d2"]*log(x1grid) + parameters["r1"]*log(x2grid) - parameters["c1"]*x2grid - parameters["c2"]*x1grid
}
ip_lotka <- outer(x1grid, x2grid, ip)
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(0.1, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  x1grid
ip <- function(parameters, x1grid, x2grid){
f = parameters["d2"]*log(x1grid) + parameters["r1"]*log(x2grid) - parameters["c1"]*x2grid - parameters["c2"]*x1grid
}
ip_lotka <- outer(x1grid, x2grid, ip)
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(0.1, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  x1grid
ip <- function(parameters, x1grid, x2grid){
f = - parameters["c1"]*x2grid - parameters["c2"]*x1grid
}
ip_lotka <- outer(x1grid, x2grid, ip)
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(0.1, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  x1grid
ip <- function(parameters, x1grid, x2grid){
f = parameters["d2"]*.log(x1grid) + parameters["r1"]*.log(x2grid) - parameters["c1"]*.x2grid - parameters["c2"]*.x1grid
}
ip_lotka <- outer(x1grid, x2grid, ip)
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(0.1, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  x1grid
ip <- function(x1grid, x2grid){
f = log(x1grid) + log(x2grid) - x2grid - x1grid
}
ip_lotka <- outer(x1grid, x2grid, ip)
library(rgl)
persp3d(x1grid,x2grid,ip_lotka)
contour(x1grid,x2grid,ip_lotka)
ip <- function(x1grid, x2grid){
f = 0.7*log(x1grid) + log(x2grid) - 0.3x2grid - 0.1x1grid
}
ip_lotka <- outer(x1grid, x2grid, ip)
ip <- function(x1grid, x2grid){
f = 0.7*log(x1grid) + log(x2grid) - 0.3*x2grid - 0.1*x1grid
}
ip_lotka <- outer(x1grid, x2grid, ip)
contour(x1grid,x2grid,ip_lotka)
persp3d(x1grid,x2grid,ip_lotka)
points(parameters["d2"]/parameters["c2"], parameters["r1"]/parameters["c1"])
plotly(x1grid,x2grid,ip_lotka, type="contour")
plotly(x=x1grid,y=x2grid,z=ip_lotka, type="contour")
plotly(ip_lotka, x=x1grid,y=x2grid, type="contour")
x = seq(-10, 10, length= 30)
y = x
f = function(x,y) { r = sqrt(log(x^2)+log(y^2)) }
z = outer(x, y, f)
plotly(x,y,z)
plotly(z,x,y)
plotly(x=x,y=x,z=z)
z
persp3d(x,y,z)
plotly(x=x,y=x,z=z, type="contour")
plotly(x,y,z, type="contour")
filled.contour(x1grid,x2grid,ip_lotka)
parameters <- c(r1 =1, c1 = 0.3, c2 = 0.1, d2= 0.7)
x1grid <-  seq(0.1, parameters["d2"]/parameters["c2"]*10, 0.3)
x2grid <-  x1grid
ip <- function(x1grid, x2grid){
f = 0.7*log(x1grid) + log(x2grid) - 0.3*x2grid - 0.1*x1grid
}
ip_lotka <- outer(x1grid, x2grid, ip)
contour(x1grid,x2grid,ip_lotka)
filled.contour(x1grid,x2grid,ip_lotka)
filled.contour(x1grid,x2grid,ip_lotka,color.palette = cm.colors)
filled.contour(x1grid,x2grid,ip_lotka,color.palette = heat.colors)
points(parameters["d2"]/parameters["c2"], parameters["r1"]/parameters["c1"])
points(parameters["d2"]/parameters["c2"], parameters["r1"]/parameters["c1"], col="black")
filled.contour(x1grid,x2grid,ip_lotka,color.palette = heat.colors, zlim = range(z, finite = TRUE),
levels = pretty(zlim, nlevels), nlevels = 20)
filled.contour(x1grid,x2grid,ip_lotka,color.palette = heat.colors, zlim = range(ip_lotka, finite = TRUE),
levels = pretty(zlim, nlevels), nlevels = 20)
zlim = range(ip_lotka, finite = TRUE)
filled.contour(x1grid,x2grid,ip_lotka,color.palette = heat.colors, zlim = range(ip_lotka, finite = TRUE), levels = pretty(zlim, nlevels), nlevels = 20)
filled.contour(x1grid,x2grid,ip_lotka,color.palette = heat.colors, nlevels = 20)
x <- seq(pi/4, 5 * pi, length.out = 100)
y <- seq(pi/4, 5 * pi, length.out = 100)
r <- as.vector(sqrt(outer(x^2, y^2, "+")))
grid <- expand.grid(x=x, y=y)
grid$z <- cos(r^2) * exp(-r/(pi^3))
levelplot(z~x*y, grid, cuts = 50, scales=list(log="e"), xlab="",
ylab="", main="Weird Function", sub="with log scales",
colorkey = FALSE, region = TRUE)
require(stats)
attach(environmental)
ozo.m <- loess((ozone^(1/3)) ~ wind * temperature * radiation,
parametric = c("radiation", "wind"), span = 1, degree = 2)
w.marginal <- seq(min(wind), max(wind), length.out = 50)
t.marginal <- seq(min(temperature), max(temperature), length.out = 50)
r.marginal <- seq(min(radiation), max(radiation), length.out = 4)
wtr.marginal <- list(wind = w.marginal, temperature = t.marginal,
radiation = r.marginal)
grid <- expand.grid(wtr.marginal)
grid[, "fit"] <- c(predict(ozo.m, grid))
contourplot(fit ~ wind * temperature | radiation, data = grid,
cuts = 10, region = TRUE,
xlab = "Wind Speed (mph)",
ylab = "Temperature (F)",
main = "Cube Root Ozone (cube root ppb)")
detach()
T <- c(-1, +1, -1, +1)  # centered and scaled temperature
S <- c(-1, -1, +1, +1)  # centered and scaled speed variable
y <- c(69, 60, 64, 53)  # conversion, is our response variable, y
doe.model <- lm(y ~ T + S + T * S)  # model with main effects, and interaction
contourPlot(doe.model)
filled.contour(x1grid,x2grid,ip_lotka,color.palette = heat.colors)
contour(x1grid,x2grid,ip_lotka, add=T)
points(parameters["d2"]/parameters["c2"], parameters["r1"]/parameters["c1"], col="black")
source('~/Dropbox/Learn_Shiny_R/Lotka_volterra_Apps/App-1-Lotka_Volterra/filled.contour2.R', echo=TRUE)
filled.contour2(x1grid,x2grid,ip_lotka,color.palette = heat.colors)
contour(x1grid,x2grid,ip_lotka, add=T)
points(parameters["d2"]/parameters["c2"], parameters["r1"]/parameters["c1"], col="black")
filled.contour2(x1grid,x2grid,ip_lotka,color.palette = heat.colors)
filled.contour2 <-
function (x = seq(0, 1, length.out = nrow(z)),
y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE),
ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE),
levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors,
col = color.palette(length(levels) - 1), plot.title, plot.axes,
key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1,
axes = TRUE, frame.plot = axes,mar, ...)
{
# modification by Ian Taylor of the filled.contour function
# to remove the key and facilitate overplotting with contour()
if (missing(z)) {
if (!missing(x)) {
if (is.list(x)) {
z <- x$z
y <- x$y
x <- x$x
}
else {
z <- x
x <- seq.int(0, 1, length.out = nrow(z))
}
}
else stop("no 'z' matrix specified")
}
else if (is.list(x)) {
y <- x$y
x <- x$x
}
if (any(diff(x) <= 0) || any(diff(y) <= 0))
stop("increasing 'x' and 'y' values expected")
mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
on.exit(par(par.orig))
w <- (3 + mar.orig[2]) * par("csi") * 2.54
par(las = las)
mar <- mar.orig
plot.new()
par(mar=mar)
plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)
if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1)
stop("no proper 'z' matrix specified")
if (!is.double(z))
storage.mode(z) <- "double"
.Internal(filledcontour(as.double(x), as.double(y), z, as.double(levels),
col = col))
if (missing(plot.axes)) {
if (axes) {
title(main = "", xlab = "", ylab = "")
Axis(x, side = 1)
Axis(y, side = 2)
}
}
else plot.axes
if (frame.plot)
box()
if (missing(plot.title))
title(...)
else plot.title
invisible()
}
filled.contour2(x1grid,x2grid,ip_lotka,color.palette = heat.colors)
plotly(ip_lotka, x=x1grid,y=x2grid, type="contour")
plotly(ip_lotka,type="contour")
plotly(ip_lotka)
plotly(z=ip_lotka, type="contour")
plot_ly(z=ip_lotka, type="contour")
points(parameters["d2"]/parameters["c2"], parameters["r1"]/parameters["c1"], col="black")
plot_ly(z=ip_lotka, type="contour") %>%
add_markers(parameters["d2"]/parameters["c2"], parameters["r1"]/parameters["c1"], col="black")
add_markers(parameters["d2"]/parameters["c2"], parameters["r1"]/parameters["c1"], col="black", type ="contour")
plot_ly(z=ip_lotka, type="contour") %>%
add_markers(parameters["d2"]/parameters["c2"], parameters["r1"]/parameters["c1"], col="black", type ="contour")
plot_ly(z=ip_lotka, type="contour") %>%
add_markers(x=parameters["d2"]/parameters["c2"], y=parameters["r1"]/parameters["c1"], col="black", type ="contour")
plot_ly(z=ip_lotka, type="contour") %>%
add_markers(x=parameters["d2"]/parameters["c2"], y=parameters["r1"]/parameters["c1"], col="black", type ="contour", marker = list(size = 15, color = "green"))
install.packages("tseriesChaos")
library(tseriesChaos)
d2(lorenz.ts, m=6, d=2, t=4, eps.min=2)
library(scatterplot3d)
x <- window(rossler.ts, start=90)
xyz <- embedd(x, m=3, d=8)
scatterplot3d(xyz, type="l")
(fn.out <- false.nearest(rossler.ts, m=6, d=8, t=180, eps=1, rt=3))
plot(fn.out)
rossler.ts <- sim.cont(rossler.syst, start=0, end=650, dt=0.1, start.x=c(0,0,0), parms=c(0.15, 0.2, 10))
plot(rossler.ts)
recurr(lorenz.ts, m=3, d=2, start.time=15, end.time=20)
